sequence(e) ::= "<e; separator=\"\n\">"
sequenceSpaced(e) ::= "<e; separator=\"\n\n\">"

wordSymbol(value) ::= <<
    .word   <value>
>>

konstantString(newStringkId, stringTag, stringObjSize, intLenkId, ascii) ::= <<
str_const<newStringkId>:
    .word   <stringTag>
    .word   <stringObjSize> <! round up len(ascii)+1 to the nearest multiple of 4 !>
    .word   String_dispTab
    .word   int_const<intLenkId>
    .asciiz "<ascii>"
    .align  2
>>

konstantInt(newIntkId, intTag, int) ::= <<
int_const<newIntkId>:
    .word   <intTag>
    .word   4
    .word   Int_dispTab
    .word   <int>
>>

konstantBool(newBoolkId, boolTag, bool) ::= <<
bool_const<newBoolkId>:
    .word   <boolTag>
    .word   4
    .word   Bool_dispTab
    .word   <bool>
>>

nameTabEntry(stringkId) ::= <<
    .word   str_const<stringkId>
>>

objTabEntry(class) ::= <<
    .word   <class>_protObj
    .word   <class>_init
>>

protObjBase(class, tag, size) ::= <<
<class>_protObj:
    .word   <tag>
    .word   <size>
    .word   <class>_dispTab
>>

protObj(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
<attrs:wordSymbol(); separator="\n">
>>
protObjObject(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
>>
protObjIO(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
>>
protObjInt(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
    .word   0
>>
protObjString(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
    .word   int_const0
    .asciiz ""
    .align  2
>>
protObjBool(class, tag, size, attrs) ::= <<
<protObjBase(class, tag, size)>
    .word   0
>>

dispTableEntry(entry) ::= <<
    .word   <entry>
>>

dispTable(class, entry) ::= <<
<class>_dispTab:
<entry:dispTableEntry(); separator="\n">
>>

loadConstant(class, id) ::= <<
    la      $a0 <class>_const<id>
>>

loadSelf() ::= <<
    move    $a0 $s0
>>

loadAttr(offset) ::= <<
    lw      $a0 <offset>($s0)
>>

pushArgument(arg) ::= <<
<arg>
    sw      $a0 0($sp)
    addiu   $sp $sp -4
>>

dispatch(instance, offset, args, uniq, filekId, line) ::= <<
<args:pushArgument()>
<instance>
    bnez    $a0 dispatch<uniq>
    la      $a0 str_const<filekId>
    li      $t1 <line>
    jal     _dispatch_abort
dispatch<uniq>:
    lw      $t1 8($a0)   # dispatch table
    lw      $t1 <offset>($t1)   # method offset
    jalr    $t1
>>

initAttr(code, offset) ::= <<
<code>
    sw      $a0 <offset>($s0)
>>

initRoutine(class, parentClass, initCode) ::= <<
<class>_init:
    addiu   $sp $sp -12
    sw      $fp 12($sp)
    sw      $s0 8($sp)
    sw      $ra 4($sp)
    addiu   $fp $sp 4
    move    $s0 $a0
<if(parentClass)>
    jal     <parentClass>_init
<endif>
<initCode>
    move    $a0 $s0
    lw      $fp 12($sp)
    lw      $s0 8($sp)
    lw      $ra 4($sp)
    addiu   $sp $sp 12
    jr      $ra
>>

userRoutine(name, code) ::= <<
<name>:
    addiu   $sp $sp -12
    sw      $fp 12($sp)
    sw      $s0 8($sp)
    sw      $ra 4($sp)
    addiu   $fp $sp 4
    move    $s0 $a0
<code>
    lw      $fp 12($sp)
    lw      $s0 8($sp)
    lw      $ra 4($sp)
    addiu   $sp $sp 12 <! TODO: should also pop the arguments (a la win32 __stdcall) !>
    jr      $ra
>>

program(tagInt, tagString, tagBool, kStrings, kInts, kBools, nameTab, objTab, objPrototypes, objDispTables, initRoutines, userRoutines) ::= <<
.data
    .align  2

    <! global visible symbols !>
    .globl  class_nameTab
    .globl  Int_protObj
    .globl  String_protObj
    .globl  bool_const0
    .globl  bool_const1
    .globl  Main_protObj
    .globl  _int_tag
    .globl  _string_tag
    .globl  _bool_tag

    <! primitive types tags !>
_int_tag:
    .word   <tagInt>
_string_tag:
    .word   <tagString>
_bool_tag:
    .word   <tagBool>

    <! constants !>
<kStrings>
<kInts>
<kBools>

class_nameTab:
<nameTab>

class_objTab:
<objTab>

<objPrototypes>

<objDispTables>

    .globl  heap_start
heap_start:
    .word   0
    .text
    .globl  Int_init
    .globl  String_init
    .globl  Bool_init
    .globl  Main_init
    .globl  Main.main
<initRoutines>

<userRoutines>
>>
